// Generated by CodiumAI

import {
  formatTypeArray,
  sortTypeResultArray,
} from "@/app/utils/typeCalculate";

describe("formatTypeArray", () => {
  // Returns an object with keys representing the multiplication or division factor and values representing the corresponding types.
  it("should return an object with keys representing the multiplication or division factor and values representing the corresponding types", () => {
    const typeArray = [1, 1, 2, 4, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    const expected = {
      "×2": ["Water"],
      "÷2": ["Electric"],
      "×4": ["Grass"],
    };
    const result = formatTypeArray(typeArray);
    console.log(result);
    expect(result).toEqual(expected);
  });

  // Returns an empty object when the input array is empty or undefined.
  it("should return an empty object when the input array is empty", () => {
    const typeArray = [];
    const expected = {};
    const result = formatTypeArray(typeArray);
    expect(result).toEqual(expected);
  });

  // Returns an empty object when the input array is empty or undefined.
  it("should return an empty object when the input array is undefined", () => {
    const typeArray = undefined;
    const expected = {};
    const result = formatTypeArray(typeArray);
    expect(result).toEqual(expected);
  });

  // Returns an object with only the keys for the multiplication or division factors present in the input array.
  it("should return an object with only the keys for the multiplication or division factors present in the input array", () => {
    const typeArray = [1, 1, 2, 4, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    const expected = {
      "×2": ["Water"],
      "÷2": ["Electric"],
      "×4": ["Grass"],
    };
    const result = formatTypeArray(typeArray);
    expect(result).toEqual(expected);
  });

  // Returns an empty object when all values in the input array are 1.
  it("should return an empty object when all values in the input array are 1", () => {
    const typeArray = [1, 1, 1];
    const expected = {};
    const result = formatTypeArray(typeArray);
    expect(result).toEqual(expected);
  });
});

// Generated by CodiumAI

describe("sortTypeResultArray", () => {
  // The function returns a sorted object based on the SORT_ORDER array.
  it("should return a sorted object based on the SORT_ORDER array", () => {
    const data = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    const expectedResult = {
      "×8": undefined,
      "×4": "value2",
      "×2": "value1",
      "÷2": "value3",
      "÷4": "value4",
      "÷8": undefined,
      X: "value5",
    };

    expect(sortTypeResultArray(data)).toEqual(expectedResult);
  });

  // The function returns an object with keys in the order specified by the order parameter.
  it("should return an object with keys in the order specified by the order parameter", () => {
    const data = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    const expectedResult = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    expect(sortTypeResultArray(data, true)).toEqual(expectedResult);
  });

  // The function returns an object with only the keys present in the input data object.
  it("should return an object with only the keys present in the input data object", () => {
    const data = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    const expectedResult = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    expect(sortTypeResultArray(data)).toEqual(expectedResult);
  });

  // The function returns an object with keys in the reverse order of the SORT_ORDER array when the order parameter is false.
  it("should return an object with keys in the reverse order of the SORT_ORDER array when the order parameter is false", () => {
    const data = {
      "×2": "value1",
      "×4": "value2",
      "÷2": "value3",
      "÷4": "value4",
      X: "value5",
    };

    const expectedResult = {
      X: "value5",
      "÷8": undefined,
      "÷4": "value4",
      "÷2": "value3",
      "×2": "value1",
      "×4": "value2",
      "×8": undefined,
    };

    expect(sortTypeResultArray(data, false)).toEqual(expectedResult);
  });

  // The function returns an empty object when the input data object is null.
  it("should return an empty object when the input data object is null", () => {
    const data = null;
    const expectedResult = {};

    expect(sortTypeResultArray(data)).toEqual(expectedResult);
  });

  // The function returns an empty object when the input data object is undefined.
  it("should return an empty object when the input data object is undefined", () => {
    const data = undefined;
    const expectedResult = {};

    expect(sortTypeResultArray(data)).toEqual(expectedResult);
  });
});
